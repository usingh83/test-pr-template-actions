name: PR Maintainer Bot
on:
  pull_request_target:
    types: [opened, edited, reopened, synchronize]

permissions:
  contents: read
  pull-requests: write
  issues: write
  checks: write

jobs:
  update-and-comment:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 1

      - name: Inject and maintain questionnaires / update maintainer fields
        uses: actions/github-script@v6
        with:
          script: |
            (async ({ github, context, core }) => {
              const owner = context.repo.owner;
              const repo = context.repo.repo;

              // Resolve PR number for PR events
              const prPayload = context.payload.pull_request || (context.payload.issue && context.payload.issue.pull_request && context.payload.issue);
              if (!prPayload || !prPayload.number) {
                core.info('No pull request in context; skipping.');
                return;
              }
              const prNumber = prPayload.number;
              const actor = context.actor;
              const checkName = 'PAR approval or Bypass questionnaire';
              const headSha = prPayload.head && prPayload.head.sha;
              
              async function setPrCheck(desiredState) {
                // desiredState: 'pending' | 'success'
                if (!headSha) return;
                // list existing check runs for the head sha with our name
                const listResp = await github.rest.checks.listForRef({
                  owner,
                  repo,
                  ref: headSha,
                  check_name: checkName,
                  per_page: 10
                });
                const run = (listResp.data.check_runs || [])[0];
                const now = new Date().toISOString();

                if (desiredState === 'pending') {
                  if (run) {
                    // only update if it's completed or not already in_progress
                    if (run.status !== 'in_progress') {
                      await github.rest.checks.update({
                        owner,
                        repo,
                        check_run_id: run.id,
                        status: 'in_progress',
                        started_at: now
                      });
                    }
                  } else {
                    await github.rest.checks.create({
                      owner,
                      repo,
                      name: checkName,
                      head_sha: headSha,
                      status: 'in_progress',
                      started_at: now
                    });
                  }
                  return;
                }

                if (desiredState === 'success') {
                  if (run) {
                    if (run.status !== 'completed' || run.conclusion !== 'success') {
                      await github.rest.checks.update({
                        owner,
                        repo,
                        check_run_id: run.id,
                        status: 'completed',
                        conclusion: 'success',
                        completed_at: now
                      });
                    }
                  } else {
                    await github.rest.checks.create({
                      owner,
                      repo,
                      name: checkName,
                      head_sha: headSha,
                      status: 'completed',
                      conclusion: 'success',
                      completed_at: now
                    });
                  }
                  return;
                }
              }
              // Optional approvers list
              let approvers = [];
              try {
                const resp = await github.rest.repos.getContent({
                  owner,
                  repo,
                  path: '.github/PAR_APPROVERS',
                  ref: prPayload.base && prPayload.base.ref
                });
                const content = Buffer.from(resp.data.content, 'base64').toString();
                approvers = content.split('\n').map(s => s.trim()).filter(Boolean);
              } catch (e) {
                core.info('.github/PAR_APPROVERS not found or unreadable; treating as empty list.');
              }

              // Markers
              const maintainerStart = '<!-- MAINTAINER-FIELDS-START -->';
              const maintainerEnd = '<!-- MAINTAINER-FIELDS-END -->';
              const questionnairesStart = '<!-- QUESTIONNAIRES-START -->';
              const questionnairesEnd = '<!-- QUESTIONNAIRES-END -->';
              const placeholder = '<!-- Maintainer-only fields will be added automatically -->';

              // Questionnaire content (checkbox style)
              const parQuestionnaire = [
                '### PAR Approval Checklist (all must be checked)',
                '- [ ] RMC attestation',
                '- [ ] ADA attestation',
                '- [ ] intent attestation',
                ''
              ].join('\n');

              const bypassQuestionnaire = [
                '### Bypass PAR Approval Questionnaire (at least one must be checked)',
                '- [ ] Hotfix - urgent',
                '- [ ] Low-risk change',
                '- [ ] Approver judgment',
                '- [ ] Business requirement',
                ''
              ].join('\n');

              const questionnaireBlock = [
                questionnairesStart,
                '**Automated questionnaires (added by bot)**',
                '',
                parQuestionnaire,
                '---',
                bypassQuestionnaire,
                '**Unselect all options to see both PAR and Bypass Questionnaire**',
                questionnairesEnd,
                ''
              ].join('\n');

              // Helper: escape regex special chars
              const esc = str => str.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');

              // Fetch latest PR body
              const { data: prData } = await github.rest.pulls.get({
                owner,
                repo,
                pull_number: prNumber
              });
              let body = prData.body || '';

              // Precompute questionnaire block regex for reuse
              const qStartEsc = esc(questionnairesStart);
              const qEndEsc = esc(questionnairesEnd);
              const qBlockRegex = new RegExp(`${qStartEsc}[\\s\\S]*?${qEndEsc}\\n?`, 'i');

              // If this is a new commit (synchronize), reset PAR approval and remove maintainer block
              if (context.payload.action === 'synchronize') {
                let newBody = body;

                // Remove maintainer block if present
                const mStartEsc = esc(maintainerStart);
                const mEndEsc = esc(maintainerEnd);
                const maintRegex = new RegExp(`${mStartEsc}[\\s\\S]*?${mEndEsc}\\n?`, 'g');
                newBody = newBody.replace(maintRegex, '');

                // Try to find existing questionnaire block and reset PAR checkboxes
                const qMatch = newBody.match(qBlockRegex);
                if (qMatch) {
                  let qBlock = qMatch[0];
                  // Use the same working regex to find the PAR section
                  const parSectionMatch = qBlock.match(/### PAR Approval Checklist[\s\S]*?(?=(\n---|\n\n|$))/i);
                  if (parSectionMatch) {
                    const parSection = parSectionMatch[0];
                    // Reset any checked box to unchecked
                    const parReset = parSection.replace(/- \[[ xX]\]/g, '- [ ]');
                    qBlock = qBlock.replace(parSection, parReset);
                    newBody = newBody.replace(qBlockRegex, qBlock);
                  }
                } else {
                  // If questionnaires were previously removed (e.g. after approval), re-insert them into the updated body
                  if (!newBody.includes(questionnairesStart)) {
                    if (newBody.includes(placeholder)) {
                      newBody = newBody.replace(placeholder, `${placeholder}\n\n${questionnaireBlock}`);
                    } else {
                      newBody = `${newBody}\n\n${questionnaireBlock}`;
                    }
                  }
                }

                // Update only when something changed
                if (newBody !== body) {
                  await github.rest.pulls.update({
                    owner,
                    repo,
                    pull_number: prNumber,
                    body: newBody
                  });
                  core.info('New commit detected: removed maintainer block, reset PAR checkboxes and ensured questionnaires are present.');
                } else {
                  core.info('New commit detected but no maintainer block or PAR checkboxes to reset.');
                }
                return;
              }
              await setPrCheck('pending');

              // Ensure questionnaires exist (inject on opened or if missing)
              if (!body.includes(questionnairesStart) && !body.includes(maintainerStart)) {
                if (context.payload.action === 'opened' || context.payload.action === 'reopened' || context.payload.action === 'edited') {
                  if (body.includes(placeholder)) {
                    body = body.replace(placeholder, `${placeholder}\n\n${questionnaireBlock}`);
                  } else {
                    body = `${body}\n\n${questionnaireBlock}`;
                  }
                  await github.rest.pulls.update({
                    owner,
                    repo,
                    pull_number: prNumber,
                    body
                  });
                  core.info('Injected questionnaires into PR body (no maintainer block present).');
                } else {
                  core.info('Questionnaires missing but not an insertion-trigger event; skipping injection.');
                }
              } else if (body.includes(questionnairesStart) && body.includes(maintainerStart)) {
                // Safety: if both exist, prefer maintainer block and remove questionnaires
                body = body.replace(qBlockRegex, '');
                await github.rest.pulls.update({ owner, repo, pull_number: prNumber, body });
                core.info('Both maintainer and questionnaires were present; removed questionnaires to enforce mutual exclusion.');
              } else {
                core.info('Questionnaires already present or maintainer block present; skipping insertion.');
              }

              // Refresh PR body after possible injection
              const { data: refreshed } = await github.rest.pulls.get({
                owner,
                repo,
                pull_number: prNumber
              });
              let refreshedBody = refreshed.body || '';

              // Extract questionnaire block (if any)
              const qBlockMatch = refreshedBody.match(qBlockRegex);
              if (!qBlockMatch) {
                core.info('No questionnaire block present; nothing to evaluate.');
                return;
              }
              const qBlock = qBlockMatch[0];

              // Find PAR Approval Checklist section within questionnaire block
              const parSectionMatch = qBlock.match(/### PAR Approval Checklist[\s\S]*?(?=(\n---|\n\n|$))/i);
              if (!parSectionMatch) {
                core.info('No PAR Approval Checklist found inside questionnaires.');
                return;
              }
              const parSection = parSectionMatch[0];

              // Find Bypass section within questionnaire block
              const bypassSectionMatch = qBlock.match(/### Bypass PAR Approval Questionnaire[\s\S]*?(?=(\n---|\n\n|$))/i);
              const bypassSection = bypassSectionMatch ? bypassSectionMatch[0] : '';

              // Count checkboxes in PAR section
              const checkboxRegex = /- \[([ xX])\]\s.*$/gm;
              let total = 0;
              let checked = 0;
              let m;
              while ((m = checkboxRegex.exec(parSection)) !== null) {
                total += 1;
                if (m[1].trim().toLowerCase() === 'x') checked += 1;
              }

              // Count checked boxes in Bypass section
              let bypassTotal = 0;
              let bypassChecked = 0;
              if (bypassSection) {
                checkboxRegex.lastIndex = 0;
                while ((m = checkboxRegex.exec(bypassSection)) !== null) {
                  bypassTotal += 1;
                  if (m[1].trim().toLowerCase() === 'x') bypassChecked += 1;
                }
              }
              const satisfied = (total > 0 && checked === total) || (bypassChecked > 0);
              if (satisfied) {
                await setPrCheck('success');
              } else {
                await setPrCheck('pending');
              }

              // Enforce section-level mutual exclusion based on partial selections:
              // - If any PAR checkbox is selected, remove the Bypass section until all PAR boxes are unselected.
              // - Else if any Bypass checkbox is selected, remove the PAR section until all Bypass boxes are unselected.
              if (checked > 0) {
                // remove bypass section if present
                if (bypassSectionMatch) {
                  let updated = refreshedBody.replace(bypassSectionMatch[0], '');
                  // remove leftover '---' separator if it remained alone
                  updated = updated.replace(/\n---\n/, '\n');
                  if (updated !== refreshedBody) {
                    await github.rest.pulls.update({ owner, repo, pull_number: prNumber, body: updated });
                    core.info('PAR items selected — removed Bypass questionnaire until PAR boxes are cleared.');
                    // ensure the PR check remains pending while PAR boxes are selected
                    await setPrCheck('pending');
                    return;
                  }
                }
              } else if (bypassChecked > 0) {
                // remove par section if present
                if (parSectionMatch) {
                  let updated = refreshedBody.replace(parSectionMatch[0], '');
                  updated = updated.replace(/\n---\n/, '\n');
                  if (updated !== refreshedBody) {
                    await github.rest.pulls.update({ owner, repo, pull_number: prNumber, body: updated });
                    core.info('Bypass item(s) selected — removed PAR questionnaire until Bypass boxes are cleared.');
                    // ensure the PR check is success if bypass meets criteria was handled later;
                    // keep check pending here because selection state may still require action
                    await setPrCheck('pending');
                    return;
                  }
                }
              } else {
                // If neither section has any boxes checked, ensure both sections are present
                if (!refreshedBody.includes(parSection)) {
                  refreshedBody = `${refreshedBody}\n\n${parSection}`;
                } else if (bypassSection && !refreshedBody.includes(bypassSection)) {
                  refreshedBody = `${refreshedBody}\n\n${bypassSection}`;
                }
                await github.rest.pulls.update({ owner, repo, pull_number: prNumber, body: refreshedBody });
                await setPrCheck('pending');
                core.info('No checklist items selected; ensured both PAR and Bypass sections are present.');
                return;
              }

              // If all PAR checkboxes are checked, update maintainer fields and remove questionnaires
              if (total > 0 && checked === total) {
                const approvalDate = new Date().toISOString().replace('T', ' ').replace(/\.\d{3}Z$/, '');
                const approverDisplay = approvers.includes(actor) ? `@${actor}` : `@${actor}`;

                const maintainerBlock = [
                  maintainerStart,
                  '**Maintainer-only fields (added by bot)**',
                  '',
                  '- PAR required: _yes_',
                  `- Approver: _${approverDisplay}_`,
                  `- Approval date: _${approvalDate}_`,
                  '',
                  '_Please do not edit the above fields; they are managed by the bot._',
                  maintainerEnd,
                  ''
                ].join('\n');

                // Remove questionnaire block entirely
                refreshedBody = refreshedBody.replace(qBlockRegex, '');

                // Replace or insert maintainer block
                const mStartEsc2 = esc(maintainerStart);
                const mEndEsc2 = esc(maintainerEnd);
                const maintRegex2 = new RegExp(`${mStartEsc2}[\\s\\S]*?${mEndEsc2}`, 'g');
                if (maintRegex2.test(refreshedBody)) {
                  refreshedBody = refreshedBody.replace(maintRegex2, maintainerBlock.trim());
                } else if (refreshedBody.includes(placeholder)) {
                  refreshedBody = refreshedBody.replace(placeholder, `${placeholder}\n\n${maintainerBlock}`);
                } else {
                  refreshedBody = `${refreshedBody}\n\n${maintainerBlock}`;
                }

                await github.rest.pulls.update({
                  owner,
                  repo,
                  pull_number: prNumber,
                  body: refreshedBody
                });
                core.info('All PAR checklist items checked — maintainer fields updated and questionnaires removed.');
                return;
              }

              core.info(`PAR checklist not fully checked (${checked}/${total}). No maintainer update.`);
            })({ github, context, core });